/*
Package config is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /go/pkg/mod/github.com/openconfig/ygot@v0.29.16/genutil/names.go
using the following YANG input files:
  - yang/app.yang

Imported modules were sourced from:
*/
package config

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

var (
	SchemaTree map[string]*yang.Entry
	ΛEnumTypes map[string][]reflect.Type
)

func init() {
	var err error
	initΛEnumTypes()
	if SchemaTree, err = UnzipSchema(); err != nil {
		panic("schema error: " + err.Error())
	}
}

// Schema returns the details of the generated schema.
func Schema() (*ytypes.Schema, error) {
	uzp, err := UnzipSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot unzip schema, %v", err)
	}

	return &ytypes.Schema{
		Root:       nil,
		SchemaTree: uzp,
		Unmarshal:  Unmarshal,
	}, nil
}

// UnzipSchema unzips the zipped schema and returns a map of yang.Entry nodes,
// keyed by the name of the struct that the yang.Entry describes the schema for.
func UnzipSchema() (map[string]*yang.Entry, error) {
	var schemaTree map[string]*yang.Entry
	var err error
	if schemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		return nil, fmt.Errorf("could not unzip the schema; %v", err)
	}
	return schemaTree, nil
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled. The supplied options (opts) are used to control the behaviour
// of the unmarshal function - for example, determining whether errors are
// thrown for unknown fields in the input JSON.
func Unmarshal(data []byte, destStruct ygot.GoStruct, opts ...ytypes.UnmarshalOpt) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn)
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree, opts...)
}

// App_Configtopus represents the /app/configtopus YANG schema element.
type App_Configtopus struct {
	ActionLeafNode        E_App_Configtopus_ActionLeafNode              `path:"action-leaf-node" module:"app"`
	ContainerWithLeaf     *App_Configtopus_ContainerWithLeaf            `path:"container-with-leaf" module:"app" yangPresence:"true"`
	ContainerWithLeafList *App_Configtopus_ContainerWithLeafList        `path:"container-with-leaf-list" module:"app"`
	ContainerWithList     *App_Configtopus_ContainerWithList            `path:"container-with-list" module:"app"`
	LeafListNode          []string                                      `path:"leaf-list-node" module:"app"`
	ListNode              map[string]*App_Configtopus_ListNode          `path:"list-node" module:"app"`
	ListWithContainer     map[string]*App_Configtopus_ListWithContainer `path:"list-with-container" module:"app"`
	ParentListNode        map[string]*App_Configtopus_ParentListNode    `path:"parent-list-node" module:"app"`
}

// IsYANGGoStruct ensures that App_Configtopus implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*App_Configtopus) IsYANGGoStruct() {}

// NewListNode creates a new entry in the ListNode list of the
// App_Configtopus struct. The keys of the list are populated from the input
// arguments.
func (t *App_Configtopus) NewListNode(Name string) (*App_Configtopus_ListNode, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ListNode == nil {
		t.ListNode = make(map[string]*App_Configtopus_ListNode)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ListNode[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ListNode", key)
	}

	t.ListNode[key] = &App_Configtopus_ListNode{
		Name: &Name,
	}

	return t.ListNode[key], nil
}

// NewListWithContainer creates a new entry in the ListWithContainer list of the
// App_Configtopus struct. The keys of the list are populated from the input
// arguments.
func (t *App_Configtopus) NewListWithContainer(Value string) (*App_Configtopus_ListWithContainer, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ListWithContainer == nil {
		t.ListWithContainer = make(map[string]*App_Configtopus_ListWithContainer)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ListWithContainer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ListWithContainer", key)
	}

	t.ListWithContainer[key] = &App_Configtopus_ListWithContainer{
		Value: &Value,
	}

	return t.ListWithContainer[key], nil
}

// NewParentListNode creates a new entry in the ParentListNode list of the
// App_Configtopus struct. The keys of the list are populated from the input
// arguments.
func (t *App_Configtopus) NewParentListNode(Name string) (*App_Configtopus_ParentListNode, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ParentListNode == nil {
		t.ParentListNode = make(map[string]*App_Configtopus_ParentListNode)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ParentListNode[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ParentListNode", key)
	}

	t.ParentListNode[key] = &App_Configtopus_ParentListNode{
		Name: &Name,
	}

	return t.ParentListNode[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["App_Configtopus"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *App_Configtopus) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of App_Configtopus.
func (*App_Configtopus) ΛBelongingModule() string {
	return "app"
}

// App_Configtopus_ContainerWithLeaf represents the /app/configtopus/container-with-leaf YANG schema element.
type App_Configtopus_ContainerWithLeaf struct {
	ChildContainerWithLeaf *App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf `path:"child-container-with-leaf" module:"app"`
	LeafDecimal            *float64                                                  `path:"leaf-decimal" module:"app"`
	LeafUint               *uint64                                                   `path:"leaf-uint" module:"app"`
}

// IsYANGGoStruct ensures that App_Configtopus_ContainerWithLeaf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*App_Configtopus_ContainerWithLeaf) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ContainerWithLeaf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["App_Configtopus_ContainerWithLeaf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ContainerWithLeaf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *App_Configtopus_ContainerWithLeaf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of App_Configtopus_ContainerWithLeaf.
func (*App_Configtopus_ContainerWithLeaf) ΛBelongingModule() string {
	return "app"
}

// App_Configtopus_ContainerWithLeafList represents the /app/configtopus/container-with-leaf-list YANG schema element.
type App_Configtopus_ContainerWithLeafList struct {
	ChildLeafList []string `path:"child-leaf-list" module:"app"`
}

// IsYANGGoStruct ensures that App_Configtopus_ContainerWithLeafList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*App_Configtopus_ContainerWithLeafList) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ContainerWithLeafList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["App_Configtopus_ContainerWithLeafList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ContainerWithLeafList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *App_Configtopus_ContainerWithLeafList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of App_Configtopus_ContainerWithLeafList.
func (*App_Configtopus_ContainerWithLeafList) ΛBelongingModule() string {
	return "app"
}

// App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf represents the /app/configtopus/container-with-leaf/child-container-with-leaf YANG schema element.
type App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf struct {
	ChildContainerWithLeafList *App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf_ChildContainerWithLeafList `path:"child-container-with-leaf-list" module:"app"`
}

// IsYANGGoStruct ensures that App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf.
func (*App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf) ΛBelongingModule() string {
	return "app"
}

// App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf_ChildContainerWithLeafList represents the /app/configtopus/container-with-leaf/child-container-with-leaf/child-container-with-leaf-list YANG schema element.
type App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf_ChildContainerWithLeafList struct {
	ChildLeafList []string `path:"child-leaf-list" module:"app"`
}

// IsYANGGoStruct ensures that App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf_ChildContainerWithLeafList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf_ChildContainerWithLeafList) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf_ChildContainerWithLeafList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf_ChildContainerWithLeafList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf_ChildContainerWithLeafList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf_ChildContainerWithLeafList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf_ChildContainerWithLeafList.
func (*App_Configtopus_ContainerWithLeaf_ChildContainerWithLeaf_ChildContainerWithLeafList) ΛBelongingModule() string {
	return "app"
}

// App_Configtopus_ContainerWithList represents the /app/configtopus/container-with-list YANG schema element.
type App_Configtopus_ContainerWithList struct {
	ChildList map[string]*App_Configtopus_ContainerWithList_ChildList `path:"child-list" module:"app"`
	LeafUint  *uint64                                                 `path:"leaf-uint" module:"app"`
}

// IsYANGGoStruct ensures that App_Configtopus_ContainerWithList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*App_Configtopus_ContainerWithList) IsYANGGoStruct() {}

// NewChildList creates a new entry in the ChildList list of the
// App_Configtopus_ContainerWithList struct. The keys of the list are populated from the input
// arguments.
func (t *App_Configtopus_ContainerWithList) NewChildList(Name string) (*App_Configtopus_ContainerWithList_ChildList, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ChildList == nil {
		t.ChildList = make(map[string]*App_Configtopus_ContainerWithList_ChildList)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ChildList[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ChildList", key)
	}

	t.ChildList[key] = &App_Configtopus_ContainerWithList_ChildList{
		Name: &Name,
	}

	return t.ChildList[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ContainerWithList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["App_Configtopus_ContainerWithList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ContainerWithList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *App_Configtopus_ContainerWithList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of App_Configtopus_ContainerWithList.
func (*App_Configtopus_ContainerWithList) ΛBelongingModule() string {
	return "app"
}

// App_Configtopus_ContainerWithList_ChildList represents the /app/configtopus/container-with-list/child-list YANG schema element.
type App_Configtopus_ContainerWithList_ChildList struct {
	Name  *string `path:"name" module:"app"`
	State *uint64 `path:"state" module:"app"`
}

// IsYANGGoStruct ensures that App_Configtopus_ContainerWithList_ChildList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*App_Configtopus_ContainerWithList_ChildList) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the App_Configtopus_ContainerWithList_ChildList struct, which is a YANG list entry.
func (t *App_Configtopus_ContainerWithList_ChildList) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ContainerWithList_ChildList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["App_Configtopus_ContainerWithList_ChildList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ContainerWithList_ChildList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *App_Configtopus_ContainerWithList_ChildList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of App_Configtopus_ContainerWithList_ChildList.
func (*App_Configtopus_ContainerWithList_ChildList) ΛBelongingModule() string {
	return "app"
}

// App_Configtopus_ListNode represents the /app/configtopus/list-node YANG schema element.
type App_Configtopus_ListNode struct {
	ChildLeafList []string `path:"child-leaf-list" module:"app"`
	Name          *string  `path:"name" module:"app"`
	State         *uint64  `path:"state" module:"app"`
}

// IsYANGGoStruct ensures that App_Configtopus_ListNode implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*App_Configtopus_ListNode) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the App_Configtopus_ListNode struct, which is a YANG list entry.
func (t *App_Configtopus_ListNode) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ListNode) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["App_Configtopus_ListNode"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ListNode) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *App_Configtopus_ListNode) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of App_Configtopus_ListNode.
func (*App_Configtopus_ListNode) ΛBelongingModule() string {
	return "app"
}

// App_Configtopus_ListWithContainer represents the /app/configtopus/list-with-container YANG schema element.
type App_Configtopus_ListWithContainer struct {
	ContainerLeaf *App_Configtopus_ListWithContainer_ContainerLeaf `path:"container-leaf" module:"app"`
	State         *uint64                                          `path:"state" module:"app"`
	Value         *string                                          `path:"value" module:"app"`
}

// IsYANGGoStruct ensures that App_Configtopus_ListWithContainer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*App_Configtopus_ListWithContainer) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the App_Configtopus_ListWithContainer struct, which is a YANG list entry.
func (t *App_Configtopus_ListWithContainer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ListWithContainer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["App_Configtopus_ListWithContainer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ListWithContainer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *App_Configtopus_ListWithContainer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of App_Configtopus_ListWithContainer.
func (*App_Configtopus_ListWithContainer) ΛBelongingModule() string {
	return "app"
}

// App_Configtopus_ListWithContainer_ContainerLeaf represents the /app/configtopus/list-with-container/container-leaf YANG schema element.
type App_Configtopus_ListWithContainer_ContainerLeaf struct {
	LeafUint *uint64 `path:"leaf-uint" module:"app"`
}

// IsYANGGoStruct ensures that App_Configtopus_ListWithContainer_ContainerLeaf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*App_Configtopus_ListWithContainer_ContainerLeaf) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ListWithContainer_ContainerLeaf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["App_Configtopus_ListWithContainer_ContainerLeaf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ListWithContainer_ContainerLeaf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *App_Configtopus_ListWithContainer_ContainerLeaf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of App_Configtopus_ListWithContainer_ContainerLeaf.
func (*App_Configtopus_ListWithContainer_ContainerLeaf) ΛBelongingModule() string {
	return "app"
}

// App_Configtopus_ParentListNode represents the /app/configtopus/parent-list-node YANG schema element.
type App_Configtopus_ParentListNode struct {
	ChildList map[string]*App_Configtopus_ParentListNode_ChildList `path:"child-list" module:"app"`
	Name      *string                                              `path:"name" module:"app"`
}

// IsYANGGoStruct ensures that App_Configtopus_ParentListNode implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*App_Configtopus_ParentListNode) IsYANGGoStruct() {}

// NewChildList creates a new entry in the ChildList list of the
// App_Configtopus_ParentListNode struct. The keys of the list are populated from the input
// arguments.
func (t *App_Configtopus_ParentListNode) NewChildList(Name string) (*App_Configtopus_ParentListNode_ChildList, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ChildList == nil {
		t.ChildList = make(map[string]*App_Configtopus_ParentListNode_ChildList)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ChildList[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ChildList", key)
	}

	t.ChildList[key] = &App_Configtopus_ParentListNode_ChildList{
		Name: &Name,
	}

	return t.ChildList[key], nil
}

// ΛListKeyMap returns the keys of the App_Configtopus_ParentListNode struct, which is a YANG list entry.
func (t *App_Configtopus_ParentListNode) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ParentListNode) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["App_Configtopus_ParentListNode"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ParentListNode) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *App_Configtopus_ParentListNode) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of App_Configtopus_ParentListNode.
func (*App_Configtopus_ParentListNode) ΛBelongingModule() string {
	return "app"
}

// App_Configtopus_ParentListNode_ChildList represents the /app/configtopus/parent-list-node/child-list YANG schema element.
type App_Configtopus_ParentListNode_ChildList struct {
	Name  *string `path:"name" module:"app"`
	State *uint64 `path:"state" module:"app"`
}

// IsYANGGoStruct ensures that App_Configtopus_ParentListNode_ChildList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*App_Configtopus_ParentListNode_ChildList) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the App_Configtopus_ParentListNode_ChildList struct, which is a YANG list entry.
func (t *App_Configtopus_ParentListNode_ChildList) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ParentListNode_ChildList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["App_Configtopus_ParentListNode_ChildList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *App_Configtopus_ParentListNode_ChildList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *App_Configtopus_ParentListNode_ChildList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of App_Configtopus_ParentListNode_ChildList.
func (*App_Configtopus_ParentListNode_ChildList) ΛBelongingModule() string {
	return "app"
}
